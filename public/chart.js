// Generated by CoffeeScript 2.3.1
(function() {
  //### templates
  var BeamWeaponData, BioticRifleWeaponData, CRIT, CircleHitBox, Enemy, HIT, HOG_HP, HitBox, MISS, PhotonProjectorWeaponData, RectHitBox, WeaponData, areascale, basicCursorHeight, chart, chart_padding_left, chart_padding_right, chart_width, crosshair, enemy, enemy_Roadhog, formatNumber, hero_filter, hero_rows, hero_selection_template, hero_weapon_template, htmlToElement, info_string, max_time, multiplier, radians, row_template, state_data, timeAxis, timeScale, timescale;

  htmlToElement = function(html) {
    var template;
    template = document.createElement('template');
    template.innerHTML = html.trim();
    return template.content.firstChild;
  };

  Handlebars.registerHelper('ceilRound', function(number) {
    return 2 * Math.ceil(number / 2);
  });

  Handlebars.registerPartial('heroWeapon', d3.select('#hero-weapon-template').html());

  hero_weapon_template = Handlebars.compile("{{> heroWeapon}}");

  row_template = Handlebars.compile(d3.select('#row-template').html());

  hero_selection_template = Handlebars.compile(d3.select('#hero-selection-template').html());

  //### timescales constants
  timescale = 60; // px/sec

  max_time = 17.5; // sec

  chart_padding_left = 15; // px

  chart_padding_right = 0; // px

  chart_width = max_time * timescale + chart_padding_left + chart_padding_right;

  timeScale = d3.scaleLinear().domain([0, max_time]).range([chart_padding_left, chart_width]);

  timescale = (function() {
    var domain, range;
    range = timeScale.range();
    domain = timeScale.domain();
    return (range[1] - range[0]) / (domain[1] - domain[0]);
  })();

  timeAxis = d3.axisTop(timeScale).ticks(20);

  d3.select("svg.timeScale").style('min-width', chart_width).style('max-width', chart_width).attr('viewBox', `0 -30 ${chart_width} 30`).append("g").call(timeAxis).append('text').text('time').attrs({
    fill: "#000",
    y: -9,
    x: chart_padding_left + timescale / 2
  });

  // 'text-anchor': 'start'    
  areascale = 2; // px^2 / hp

  radians = Math.PI / 180;

  formatNumber = function(num, d = 1) {
    if (Math.abs(Math.round(num) - num) < 0.01) {
      return d3.format('d')(num);
    } else {
      return d3.format(`.${d}f`)(num);
    }
  };

  //### Enemy shooting

  //constants
  CRIT = 2;

  HIT = 1;

  MISS = 0;

  basicCursorHeight = 1; //m

  
  //global
  multiplier = 1;

  crosshair = {
    x: 0,
    z: 1.0,
    distance: 5.0
  };

  HitBox = class HitBox {
    registerHit() {
      return false;
    }

    appendElement(g) {
      return g;
    }

  };

  RectHitBox = class RectHitBox extends HitBox {
    constructor(cx, cz, width, height) {
      super();
      this.x1 = cx - width / 2;
      this.x2 = cx + width / 2;
      this.z1 = cz - height / 2;
      this.z2 = cz + height / 2;
    }

    registerHit(p) {
      return this.x1 <= p.x && p.x <= this.x2 && this.z1 <= p.z && p.z <= this.z2;
    }

    appendElement(g) {
      return g.append('rect').attrs({
        x: this.x1,
        y: basicCursorHeight - this.z2,
        width: this.x2 - this.x1,
        height: this.z2 - this.z1
      });
    }

  };

  CircleHitBox = class CircleHitBox extends HitBox {
    constructor(x1, z1, radius1) {
      super();
      this.x = x1;
      this.z = z1;
      this.radius = radius1;
      this.radius_squared = this.radius * this.radius;
    }

    registerHit(p) {
      var dx, dz;
      dx = p.x - this.x;
      dz = p.z - this.z;
      return dx * dx + dz * dz <= this.radius_squared;
    }

    appendElement(g) {
      return g.append('circle').attrs({
        cx: this.x,
        cy: basicCursorHeight - this.z,
        r: this.radius
      });
    }

  };

  Enemy = class Enemy {
    constructor(image, body, head) {
      this.image = image;
      this.body = body;
      this.head = head;
    }

    registerHit(point) {
      switch (false) {
        case !this.head.registerHit(point):
          return CRIT;
        case !this.body.registerHit(point):
          return HIT;
        default:
          return MISS;
      }
    }

    shoot(crosshair, radius = 0, shift_x = 0, shift_z = 0) {
      var cx, cz, phi, r, x, z;
      cx = cz = 0;
      if (radius > 0) {
        phi = 2 * Math.PI * Math.random();
        r = radius * Math.random();
        cx = r * Math.cos(phi);
        cz = r * Math.sin(phi);
      }
      x = crosshair.x + cx + shift_x;
      z = crosshair.z + cz + shift_z;
      return this.registerHit({
        x: x,
        z: z
      });
    }

  };

  enemy_Roadhog = (function() {
    var body_height, body_width, head_height, head_width;
    body_width = 1.4;
    body_height = 2.1;
    head_height = 2.0;
    head_width = 0.6;
    return new Enemy({
      url: "images/roadhog_figure_lighter.png",
      dims: {
        width: 858,
        height: 873
      },
      x: 1.55,
      y: 1.6,
      height: 3.3
    }, new RectHitBox(0, body_height / 2, body_width, body_height), new CircleHitBox(0, head_height, head_width / 2));
  })();

  
  // ht = 2.21
  // basicRectangle = new RectHitBox(0,ht/2,2,ht)
  enemy = enemy_Roadhog;

  HOG_HP = 600;

  WeaponData = (function() {
    var total_time;

    class WeaponData {
      // draw_time = 1.2*max_time
      constructor(weapon1) {
        var ref, shot_spacing;
        this.weapon = weapon1;
        this.order = this.weapon.index + 1;
        shot_spacing = timescale * (((ref = this.weapon.burst) != null ? ref.delay : void 0) || this.weapon.shot_time);
        this.filling = this.weapon.filling || 0.5;
        this.is_beam = this.weapon.type === "beam";
        this.color = this.weapon.hero.color;
        this.segments_factor = this.weapon.damage.segments || 1;
        if (!this.is_beam) {
          this.max_shot_width = shot_spacing * this.filling;
          this.max_square_dmg = this.max_shot_width * this.max_shot_width / areascale;
        }
      }

      refresh_distance(enemy, crosshair) {
        this.set_distance(crosshair.distance);
        this.init_shots();
        this.simulate_shot_outcomes(enemy, crosshair);
        return this.calculate_shots_damage();
      }

      refresh_crosshair(enemy, crosshair) {
        this.simulate_shot_outcomes(enemy, crosshair);
        return this.calculate_shots_damage();
      }

      set_distance(distance) {
        this.distance = distance;
        this.pellets = this.weapon.pellets_func != null ? this.weapon.pellets_func(distance) : this.weapon.pellets;
        this.basic_dmg = this.weapon.basic_damage_func(distance);
        this.radius_func = this.weapon.make_radius_func(distance);
        this.time_delay = this.weapon.time_delay_func(distance);
        return this.shift_func = this.weapon.make_shift_func(distance);
      }

      init_shots() {
        var ammo, ammo_consumed, dt, results, shot, t, total_dmg;
        t = 0;
        this.shots = [];
        ammo = this.weapon.ammo;
        total_dmg = 0;
        results = [];
        while (t < total_time) {
          shot = {
            radius: this.radius_func(ammo, t)
          };
          [ammo, dt, ammo_consumed] = this.weapon.shot_time_func(ammo, t);
          shot.t = t + this.time_delay;
          shot.wdata = this;
          if (ammo_consumed > 1) {
            shot.ammo_mult = ammo_consumed;
          }
          if (this.weapon.type === "beam") {
            shot.duration = this.weapon.shot_time * ammo_consumed;
          }
          if (this.weapon.type.match(/EOT/)) {
            shot.duration = this.weapon.damage.duration;
          }
          this.shots.push(shot);
          results.push(t += dt);
        }
        return results;
      }

      simulate_shot_outcomes(enemy, crosshair) {
        var COS, SIN, hit_outcome, i, j, k, len, o, outcomes, random_angle, ref, ref1, ref2, shift, shot, total, total_outcomes;
        total_outcomes = [0, 0, 0];
        ref = this.shots;
        for (j = 0, len = ref.length; j < len; j++) {
          shot = ref[j];
          outcomes = [0, 0, 0];
          if ((ref1 = this.weapon.spread) != null ? ref1.randomly_rotated : void 0) {
            random_angle = 2 * Math.PI * Math.random();
            SIN = Math.sin(random_angle);
            COS = Math.cos(random_angle);
          } else {
            SIN = 0;
            COS = 1;
          }
          for (i = k = 1, ref2 = this.pellets; (1 <= ref2 ? k <= ref2 : k >= ref2); i = 1 <= ref2 ? ++k : --k) {
            shift = this.shift_func(i);
            hit_outcome = enemy.shoot(crosshair, shot.radius, COS * shift[0] - SIN * shift[1], COS * shift[1] + SIN * shift[0]);
            outcomes[hit_outcome] += 1;
          }
          if (this.weapon.crit_factor === 1) {
            outcomes[HIT] += outcomes[CRIT];
            outcomes[CRIT] = 0;
          }
          shot.outcomes = outcomes;
          total_outcomes[MISS] += outcomes[MISS];
          total_outcomes[HIT] += outcomes[HIT];
          total_outcomes[CRIT] += outcomes[CRIT];
        }
        total = total_outcomes[MISS] + total_outcomes[HIT] + total_outcomes[CRIT];
        return this.outcomes = (function() {
          var l, len1, results;
          results = [];
          for (l = 0, len1 = total_outcomes.length; l < len1; l++) {
            o = total_outcomes[l];
            results.push(o / total);
          }
          return results;
        })();
      }

      calculate_shots_damage() {
        var h, index, j, k, key, last_shot, len, len1, mean_damage, ref, ref1, shot, time, total_dmg;
        this.height = 0;
        this.hit_dmg = this.basic_dmg * modificator.factor;
        this.crit_dmg = this.hit_dmg * this.weapon.crit_factor;
        if (modificator.mods.armor.on) {
          ref = ['hit_dmg', 'crit_dmg'];
          for (j = 0, len = ref.length; j < len; j++) {
            key = ref[j];
            this[key] = modificator.mods.armor.func(this[key]);
          }
        }
        total_dmg = 0;
        this.rhkt = void 0;
        ref1 = this.shots;
        for (index = k = 0, len1 = ref1.length; k < len1; index = ++k) {
          shot = ref1[index];
          shot.damage = (shot.outcomes[HIT] * this.hit_dmg + shot.outcomes[CRIT] * this.crit_dmg) * this.segments_factor;
          h = this.shot_dimensions(shot);
          total_dmg += shot.damage;
          if (this.rhkt == null) {
            this.rhkt = total_dmg >= HOG_HP ? shot.t + (shot.duration ? (total_dmg - HOG_HP) / shot.damage * shot.duration : 0) : void 0;
          }
          if (h > this.height) {
            this.height = h;
          }
        }
        last_shot = this.shots[this.shots.length - 1];
        time = last_shot.t;
        if (last_shot.duration != null) {
          time += last_shot.duration;
        }
        this.dps_raw = total_dmg / time;
        mean_damage = (this.hit_dmg * this.outcomes[HIT] + this.crit_dmg * this.outcomes[CRIT]) * this.pellets * this.segments_factor;
        this.dps_wort = mean_damage / this.weapon.dps_period_base;
        this.dps = mean_damage / (this.weapon.dps_period_base + this.weapon.dps_period_add);
        if (this.rhkt == null) {
          this.rhkt = this.dps > 0 ? HOG_HP / this.dps : 2e308;
        }
        return this.height = 2 * Math.ceil(this.height / 2);
      }

      shot_dimensions(shot) {
        if (shot.damage > this.max_square_dmg) {
          shot.width = this.max_shot_width;
          shot.height = areascale * shot.damage / shot.width;
        } else {
          shot.width = Math.sqrt(areascale * shot.damage);
          shot.height = shot.width;
        }
        return shot.height;
      }

    };

    total_time = 1.2 * max_time;

    return WeaponData;

  }).call(this);

  BeamWeaponData = class BeamWeaponData extends WeaponData {
    shot_dimensions(shot) {
      shot.damage *= shot.duration * this.weapon.fire_rate;
      shot.dps = shot.damage / shot.duration;
      return shot.height = shot.dps * areascale / timescale;
    }

  };

  //beam mech
  BioticRifleWeaponData = class BioticRifleWeaponData extends WeaponData {
    shot_dimensions(shot) {
      var dps;
      dps = shot.damage / shot.duration;
      return shot.height = dps * areascale / timescale;
    }

  };

  //beam mech
  PhotonProjectorWeaponData = class PhotonProjectorWeaponData extends BeamWeaponData {
    calculate_shots_damage() {
      var basic_dmg, dmg, factor, h, index, j, k, last_shot, len, len1, mean_damage, ref, ref1, shot, time, total_dmg;
      this.height = 30;
      this.hit_dmg = this.basic_dmg * modificator.factor;
      this.dmg_levels = [];
      ref = this.weapon.damage.dps_factors;
      for (j = 0, len = ref.length; j < len; j++) {
        factor = ref[j];
        this.dmg_levels.push(this.hit_dmg * factor);
      }
      if (modificator.mods.armor.on) {
        this.dmg_levels = (function() {
          var k, len1, ref1, results;
          ref1 = this.dmg_levels;
          results = [];
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            dmg = ref1[k];
            results.push(modificator.mods.armor.func(dmg));
          }
          return results;
        }).call(this);
      }
      total_dmg = 0;
      this.rhkt = void 0;
      ref1 = this.shots;
      for (index = k = 0, len1 = ref1.length; k < len1; index = ++k) {
        shot = ref1[index];
        basic_dmg = index >= this.dmg_levels.length ? this.dmg_levels[this.dmg_levels.length - 1] : this.dmg_levels[index];
        shot.damage = shot.outcomes[HIT] * basic_dmg;
        h = this.shot_dimensions(shot);
        total_dmg += shot.damage;
        if (this.rhkt == null) {
          this.rhkt = total_dmg >= HOG_HP ? shot.t + (total_dmg - HOG_HP) / shot.damage * shot.duration : void 0;
        }
        if (h > this.height) {
          this.height = h;
        }
      }
      last_shot = this.shots[this.shots.length - 1];
      time = last_shot.t + last_shot.duration;
      this.dps_raw = total_dmg / time;
      mean_damage = this.outcomes[HIT] * this.dmg_levels[this.dmg_levels.length - 1];
      this.dps_wort = mean_damage / this.weapon.dps_period_base;
      this.dps = mean_damage / (this.weapon.dps_period_base + this.weapon.dps_period_add);
      return this.height = 2 * Math.ceil(this.height / 2);
    }

  };

  // info string 
  info_string = (function() {
    var percent_str;
    percent_str = function(val) {
      var str;
      str = (100 * val).toFixed(1);
      str = (function() {
        switch (str) {
          case '0.0':
            return '0';
          case '100.0':
            return '100';
          default:
            return str;
        }
      })();
      return `${str}%`;
    };
    info_string = {
      current: 0,
      variants: [
        {
          name: 'dps',
          text: 'Mean DPS',
          func: function(wdata) {
            var ref;
            return (ref = wdata.dps) != null ? ref.toFixed(1) : void 0;
          }
        },
        {
          name: 'dps_wort',
          text: 'Mean DPS w/o reload',
          func: function(wdata) {
            var ref;
            return (ref = wdata.dps_wort) != null ? ref.toFixed(1) : void 0;
          }
        },
        {
          name: 'acc',
          text: 'Accuracy',
          func: function(wdata) {
            var acc;
            acc = wdata.outcomes[HIT] + wdata.outcomes[CRIT];
            return percent_str(acc);
          }
        },
        {
          name: 'crit_acc',
          text: 'Crit accur.',
          func: function(wdata) {
            var acc;
            if (wdata.weapon.crit_factor === 1) {
              return 'n/a';
            } else {
              acc = wdata.outcomes[CRIT];
              return percent_str(acc);
            }
          }
        },
        {
          name: 'rhkt',
          text: 'Kill time',
          func: function(wdata) {
            var ref;
            if (wdata.rhkt === 2e308) {
              return "∞";
            } else {
              return `${(ref = wdata.rhkt) != null ? ref.toFixed(1) : void 0}s`;
            }
          }
        }
      ],
      cv: function() {
        return this.variants[this.current];
      },
      text: function(wdata) {
        return this.cv().func(wdata);
      },
      increment: function() {
        this.current += 1;
        return this.current = this.current % this.variants.length;
      },
      update_rows: function() {
        hero_rows.rows.select('.info-string').text(function(wdata) {
          return info_string.text(wdata);
        });
        return hero_filter.reloadOrder();
      }
    };
    d3.select('.nav-toggle-info').on('click', function() {
      var str;
      info_string.increment();
      info_string.update_rows();
      str = info_string.cv().text;
      return d3.select(this).select('a').text(str);
    });
    return info_string;
  })();

  chart = d3.select(".chart");

  state_data = (function() { //weapons, enemy, distance, crosshair 
    var j, len, list, wdata, weapon;
    list = [];
    for (j = 0, len = weapons.length; j < len; j++) {
      weapon = weapons[j];
      wdata = (function() {
        switch (false) {
          case weapon.name !== 'Photon Projector':
            return new PhotonProjectorWeaponData(weapon);
          case weapon.type !== 'beam':
            return new BeamWeaponData(weapon);
          case !weapon.type.match(/EOT/):
            return new BioticRifleWeaponData(weapon);
          default:
            return new WeaponData(weapon);
        }
      })();
      wdata.refresh_distance(enemy, crosshair);
      list.push(wdata);
    }
    return {
      // state object
      list: list,
      shot_attrs: {
        height: function(shot) {
          return shot.height;
        },
        y: function(shot) {
          return -shot.height / 2;
        },
        x: function(shot) {
          var shift_x;
          shift_x = shot.duration != null ? 0 : shot.width / 2;
          return timeScale(shot.t) - shift_x;
        },
        width: function(shot) {
          if (shot.duration != null) {
            return shot.duration * timescale;
          } else {
            return shot.width;
          }
        }
      },
      refresh_distance: function(enemy, crosshair) {
        var k, len1, ref;
        ref = this.list;
        for (k = 0, len1 = ref.length; k < len1; k++) {
          wdata = ref[k];
          wdata.refresh_distance(enemy, crosshair);
        }
        return this.update_damage();
      },
      refresh_crosshair: function(enemy, crosshair) {
        var k, len1, ref;
        ref = this.list;
        for (k = 0, len1 = ref.length; k < len1; k++) {
          wdata = ref[k];
          wdata.refresh_crosshair(enemy, crosshair);
        }
        return this.update_damage();
      },
      update_row_heights: function(rows) {
        return rows.style('min-height', function(wdata) {
          var h;
          h = wdata.weapon.visible ? 4 + Math.max(46, wdata.height) : 0;
          return `${h}px`;
        });
      },
      update_damage: function(update = 'all') {
        var k, len1, row_selector, rows, svgs, update_list;
        if (update === 'all') {
          row_selector = 'div.row';
          update_list = this.list;
        } else {
          row_selector = 'div#' + update.idString;
          update_list = [this.list[update.index]];
        }
        for (k = 0, len1 = update_list.length; k < len1; k++) {
          wdata = update_list[k];
          wdata.calculate_shots_damage();
        }
        rows = chart.selectAll(row_selector);
        this.update_row_heights(rows);
        rows.select('.info-string').text(function(wdata) {
          return info_string.text(wdata);
        });
        hero_filter.reloadOrder();
        svgs = rows.select('svg');
        return svgs.selectAll('rect.shot').data(function(wdata) {
          return wdata.shots;
        }).transition().duration(100).attrs(this.shot_attrs);
      }
    };
  })();

  
  // init hero rows
  hero_rows = (function() { // state_data
    var rows, shots, svgs, tooltip;
    rows = chart.selectAll("div.row").data(state_data.list).enter().append(function(wdata) {
      return htmlToElement(row_template(wdata));
    });
    rows.select('.info-string').text(function(wdata) {
      return info_string.text(wdata);
    });
    tooltip = d3.select("body").append("div").attr("class", "tooltip").style("opacity", 0);
    svgs = rows.select('svg').style('min-width', chart_width).style('max-width', chart_width).attrs({
      viewBox: `0 -100 ${chart_width} 200`
    });
    shots = svgs.selectAll('rect.shot').data(function(wdata) {
      return wdata.shots;
    }).enter().append('rect').classed('shot', true).attrs(state_data.shot_attrs).attr('fill', function(shot) {
      return shot.wdata.color;
    }).on("mouseover", function(d) {
      var num, units;
      tooltip.transition().duration(200).style("opacity", .9);
      [num, units] = d.dps != null ? [d.dps, "dps"] : [d.damage, "hp"];
      return tooltip.html(`${formatNumber(num, 2)} ${units}`).style("left", `${d3.event.pageX}px`).style("top", `${d3.event.pageY - 28}px`);
    }).on("mouseout", function(d) {
      return tooltip.transition().duration(500).style("opacity", 0);
    });
    return {
      rows: rows,
      svgs: svgs,
      shots: shots
    };
  })();

  // hero filterting
  hero_filter = (function() {
    var ease, hero_selection_el, sel_weapons, sort_by_field, toggleSelect, toggleSort;
    hero_filter = {
      init_order: true
    };
    hero_selection_el = d3.select('.hero-selection-row');
    hero_selection_el.display = "none";
    toggleSelect = d3.selectAll('.nav-toggle-select').on("click", function() {
      var h, toggle;
      toggle = !toggleSelect.classed('nav-selected');
      toggleSelect.classed('nav-selected', toggle);
      if (toggle) {
        hero_selection_el.classed('hidden-row', !toggle);
        h = hero_selection_el.style('height');
        hero_selection_el.style('height', "0px");
        hero_selection_el.transition().duration(400).style('height', h);
      } else {
        h = hero_selection_el.style('height');
        hero_selection_el.style('height', h);
        hero_selection_el.transition().duration(400).style('height', "0px");
      }
      return setTimeout(function() {
        h = hero_selection_el.style('height');
        hero_selection_el.style('height', void 0);
        if (h === '0px') {
          return hero_selection_el.classed('hidden-row', true);
        }
      }, 2000);
    });
    toggleSort = d3.selectAll('.nav-toggle-sort').on('click', function() {
      hero_filter.init_order = !hero_filter.init_order;
      hero_filter.reloadOrder();
      return toggleSort.classed('nav-selected', !toggleSort.classed('nav-selected'));
    });
    sel_weapons = d3.select('.hero-selection').selectAll('div').data(weapons).enter().append(function(weapon) {
      return htmlToElement(hero_selection_template(weapon));
    }).on('click', function(weapon) {
      weapon.visible = !weapon.visible;
      return hero_filter.reloadVisibility([weapon]);
    });
    hero_filter.reloadVisibility = function(weapons = sel_weapons) {
      sel_weapons.style('background-color', function(weapon) {
        if (weapon.visible) {
          return weapon.hero.color;
        } else {
          return 'initial';
        }
      }).classed('inverse', function(weapon) {
        return !weapon.visible;
      });
      hero_rows.rows.style('opacity', function(wdata) {
        if (wdata.weapon.visible) {
          return 1;
        } else {
          return 0;
        }
      }).style('order', function(wdata) {
        return wdata.order;
      });
      return state_data.update_row_heights(hero_rows.rows);
    };
    hero_rows.rows.each(function(wdata) {
      TweenLite.set(this, {
        y: 0
      });
      return wdata.tween_box = {
        transform: this._gsTransform,
        x: this.offsetLeft,
        y: this.offsetTop,
        node: this
      };
    });
    sort_by_field = function(field) {
      var local_f;
      local_f = (function() {
        switch (field) {
          case 'dps':
            return function(d) {
              return d.dps;
            };
          case 'dps_wort':
            return function(d) {
              return d.dps_wort;
            };
          case 'acc':
            return function(d) {
              return d.outcomes[HIT] + d.outcomes[CRIT];
            };
          case 'crit_acc':
            return function(d) {
              return d.outcomes[CRIT];
            };
          case 'rhkt':
            return function(d) {
              return -d.rhkt;
            };
          default:
            return function(d) {
              return -d.weapon.index;
            };
        }
      })();
      return function(a, b) {
        var A, B;
        A = local_f(a.wdata);
        B = local_f(b.wdata);
        if (A < B) {
          return 1;
        }
        if (A > B) {
          return -1;
        }
        return a.idx - b.idx;
      };
    };
    ease = Power1.easeInOut;
    hero_filter.reloadOrder = function() {
      var ch, changed, sort_arr;
      changed = hero_filter.init_order ? (ch = false, _.each(state_data.list, function(wdata) {
        ch || (ch = wdata.order !== (wdata.weapon.index + 1));
        return wdata.order = wdata.weapon.index + 1;
      }), ch) : (sort_arr = _.map(state_data.list, function(wdata, idx) {
        return {
          idx: wdata.order,
          wdata: wdata
        };
      }), sort_arr.sort(sort_by_field(info_string.cv().name)), ch = false, _.each(sort_arr, function(d, idx) {
        ch || (ch = idx !== d.idx);
        return d.wdata.order = idx;
      }), ch);
      if (changed) {
        return hero_rows.rows.style('order', function(wdata) {
          return wdata.order;
        }).each(function(wdata) {
          var box, lastX, lastY, x, y;
          box = wdata.tween_box;
          lastX = box.x;
          lastY = box.y;
          box.x = box.node.offsetLeft;
          box.y = box.node.offsetTop;
          
          //Continue if box hasn't moved
          if (lastX === box.x && lastY === box.y) {
            return;
          }
          
          //Reversed delta values taking into account current transforms
          x = box.transform.x + lastX - box.x;
          y = box.transform.y + lastY - box.y;
          return TweenLite.fromTo(box.node, 0.5, {x, y}, {
            x: 0,
            y: 0,
            ease
          });
        });
      }
    };
    d3.select('.select-all').on('click', () => {
      var j, len, ref, weapon;
      ref = this.weapons;
      for (j = 0, len = ref.length; j < len; j++) {
        weapon = ref[j];
        weapon.visible = true;
      }
      return reloadVisibility();
    });
    d3.select('.select-none').on('click', function() {
      var j, len, weapon;
      for (j = 0, len = weapons.length; j < len; j++) {
        weapon = weapons[j];
        weapon.visible = false;
      }
      return hero_filter.reloadVisibility();
    });
    d3.selectAll('.select-by-role').on('click', function() {
      var j, len, role, weapon;
      role = d3.select(this).attr('data-role');
      for (j = 0, len = weapons.length; j < len; j++) {
        weapon = weapons[j];
        weapon.visible = weapon.hero.role === role;
      }
      return hero_filter.reloadVisibility();
    });
    d3.selectAll('.select-by-weapon').on('click', function() {
      var j, len, weapon, wtype;
      wtype = d3.select(this).attr('data-weapon');
      for (j = 0, len = weapons.length; j < len; j++) {
        weapon = weapons[j];
        weapon.visible = _.includes(weapon.type, wtype);
      }
      return hero_filter.reloadVisibility();
    });
    return hero_filter;
  })();

  // state_data.update_damage()
  hero_filter.reloadVisibility();

  (function() {    // distance slider
    //enemy, crosshair, state_data
    var local_update_dist, slider, update_distance, viewport;
    local_update_dist = false;
    update_distance = function(val, update_slider = false, update_input = false) {
      crosshair.distance = (function() {
        switch (false) {
          case !isNaN(val):
            return 5;
          case !(val < 0.1):
            return 0.1;
          default:
            return val;
        }
      })();
      viewport.setscale(crosshair.distance);
      viewport.updateDummyFigure();
      state_data.refresh_distance(enemy, crosshair);
      if (update_input) {
        slider.input.property('value', crosshair.distance.toFixed(2));
      }
      if (update_slider) {
        local_update_dist = true;
        slider.slider.value(crosshair.distance);
        return local_update_dist = false;
      }
    };
    // slider
    slider = (function() {
      var g, input;
      input = d3.select('.distance-panel input').attr('value', crosshair.distance).on('change', function() {
        var val;
        val = parseFloat(input.property('value'));
        return update_distance(val, true, false);
      });
      slider = d3.sliderHorizontal().min(0).max(50).width(295).tickFormat(d3.format('.1f')).ticks(6).default(crosshair.distance).on('onchange', _.throttle(function(val) {
        if (!local_update_dist) {
          return update_distance(val, false, true);
        }
      }, 100));
      g = d3.select("div#distance-slider").append("svg").attr("width", 400).attr("height", 50).append("g").attr("transform", "translate(20,10)");
      g.call(slider);
      return {
        slider: slider,
        input: input
      };
    })();
    // enemy viewport
    return viewport = (function() { //enemy
      var drag, dragended, dragged, dragstarted, dummyFigure, events_cnt, setEnemyFigure, start_time, throttle_refresh_crosshair, throttle_update_position;
      start_time = 0;
      events_cnt = 0;
      dragstarted = function(d) {
        start_time = Date.now();
        events_cnt = 0;
        return d3.select(this).raise().classed("dragging", true);
      };
      throttle_refresh_crosshair = _.throttle(function(enemy, crosshair) {
        viewport.update_crosshair(crosshair);
        return state_data.refresh_crosshair(enemy, crosshair);
      }, 100, {
        leading: true
      });
      throttle_update_position = _.throttle(function() {
        events_cnt += 1;
        return viewport.updateDummyFigure();
      }, 16, {
        leading: true
      });
      dragged = function(d) {
        d.x += d3.event.dx;
        d.y += d3.event.dy;
        return throttle_update_position();
      };
      // throttle_refresh_crosshair(enemy, crosshair)
      dragended = function(d) {
        var duration;
        duration = (Date.now() - start_time) / 1000;
        throttle_refresh_crosshair(enemy, crosshair);
        return d3.select(this).classed("dragging", false);
      };
      viewport = {
        x: 0,
        y: 0,
        scale: 1,
        createTransformString: function() {
          return `translate(${this.x} ${this.y}) scale(${this.scale})`;
        },
        setscale: function(distance) {
          this.x /= this.scale;
          this.y /= this.scale;
          this.scale = 1.0 / distance / radians;
          this.x *= this.scale;
          return this.y *= this.scale;
        },
        update_crosshair: function(crosshair) {
          crosshair.z = basicCursorHeight + this.y / this.scale;
          return crosshair.x = this.x / this.scale;
        },
        updateDummyFigure: function() {
          return dummyFigure.attr('transform', function(d) {
            return d.createTransformString();
          });
        }
      };
      viewport.setscale(crosshair.distance);
      drag = d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
      dummyFigure = d3.select('svg.figure_chart g.figure').data([viewport]).call(drag);
      viewport.updateDummyFigure();
      setEnemyFigure = function() {
        dummyFigure.select('image').attrs({
          x: -enemy.image.x,
          y: -enemy.image.height + enemy.image.y,
          height: enemy.image.height,
          width: enemy.image.height * enemy.image.dims.width / enemy.image.dims.height,
          'xlink:href': enemy.image.url
        });
        enemy.body.appendElement(dummyFigure).classed('figure_body', true);
        return enemy.head.appendElement(dummyFigure).classed('figure_head', true);
      };
      // basicRectangle
      //   .appendElement(dummyFigure)
      //   .styles
      //     fill: "none"
      //     "stroke-width": 0.05
      //     stroke: "rgb(0,255,0)"
      setEnemyFigure();
      return viewport;
    })();
  })();

  (function() {    // modificators
    var set_multiplier_string;
    set_multiplier_string = function() {
      var str;
      str = `${this.modificator.factor}×`;
      if (modificator.mods.armor.on) {
        str += " – armor";
      }
      return d3.select('.mod-result').text(str);
    };
    return d3.select('.modificators').selectAll('.hero-ability-icon-bg').data(modificator.mod_list).classed('inverse', true).style('background-color', 'transparent').on('click', function(m) {
      m.on = !m.on;
      d3.select(this).classed('inverse', !m.on).style('background-color', m.on ? m.color : 'transparent');
      modificator.refresh_factor();
      set_multiplier_string();
      return state_data.update_damage();
    });
  })();

  // zarya energy sliders
  (function(weapon_dict) {
    return d3.selectAll('.hero-slider').each(function() {
      return new Dragdealer(this, {
        animationCallback: function(x, y) {
          var el, energy, name, wdata, weapon;
          energy = Math.round(x * 100);
          el = d3.select(this.wrapper);
          el.select('.handle').text(energy);
          name = el.attr('data-weapon-name');
          weapon = weapon_dict[name];
          weapon.energy = energy;
          wdata = state_data.list[weapon.index];
          wdata.set_distance(crosshair.distance);
          return state_data.update_damage(weapon);
        }
      });
    });
  })(weapon_dict);

  // plot data calculations

// download_file = (data, filename, type="text/plain") ->
//     file = new Blob([data], {type: type})
//     if (window.navigator.msSaveOrOpenBlob)
//         window.navigator.msSaveOrOpenBlob(file, filename)
//     else
//         a = document.createElement("a")
//         url = URL.createObjectURL(file)
//         a.href = url
//         a.download = filename
//         document.body.appendChild(a)
//         a.click()
//         setTimeout( ->
//             document.body.removeChild(a)
//             window.URL.revokeObjectURL(url)
//         , 0)

// do -> 
//   d = 0.1
//   texts = []
//   while d <= 50.1
//   # do ->
//     crosshair = {x:0, z: 2.0, distance: d}
//     for wdata in state_data.list
//       wdata.refresh_distance(enemy, crosshair)
//     nums = [d].concat(wdata.dps for wdata in state_data.list)
//     texts.push nums.join("\t")
//     console.log(d)
//     d+=0.1
//   data = texts.join("\n")
//   download_file data, "data.txt"

// do -> 
//   texts = []
//   for wdata in state_data.list
//     fields = [wdata.weapon.hero.name,
//               wdata.weapon.hero.color,
//               wdata.weapon.name ]
//     texts.push fields.join("\t")
//   data = texts.join("\n")
//   download_file data, "legend.txt"

}).call(this);
